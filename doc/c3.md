# C3 : Product

Este capítulo descreve o desenvolvimento do produto, a sua instalação, utilização e detalhes técnicos de implementação.

---

## 3.1 Development

O desenvolvimento da API Car4Me foi realizado seguindo uma arquitetura **RESTful**, utilizando **Node.js + Express** no backend e **MySQL** como base de dados relacional. O sistema foi implementado de forma modular, garantindo clareza, reusabilidade e fácil manutenção.

A API foi separada nos seguintes módulos principais:

- Clientes  
- Veículos  
- Categorias  
- Reservas  
- Funcionários  
- Manutenções  
- Favoritos (relação N:N)  

Cada módulo possui:

- **Rota**  
- **Controller**  
- **Validações**  
- **Queries SQL**  

Assim assegura-se isolamento e coerência no produto.

> **[INSERIR AQUI]**  
> ![Arquitetura do Sistema](./imagens/c3/arquitetura_api.png)

### 3.1.1 Arquitetura da API

- Requests HTTP são recebidos nas rotas  
- Os controladores tratam da lógica  
- A base de dados armazena toda a informação  
- Respostas são devolvidas em JSON  

---

## 3.2 Installation

A API foi construída para ser executada de forma simples e portátil com **Docker**.

### 3.2.1 Passos de instalação

1. Instalar **Docker** e **Docker Compose**
2. Clonar o repositório:

```bash
git clone <url-do-projeto>
cd car4me
```

## 3.2 Installation

### 3.2.1 Requisitos
- Docker
- Docker Compose
- Node.js (opcional, apenas para ambiente local)

### 3.2.2 Instalação

```bash
git clone <repo>
cd car4me
docker compose up -d
```

### 3.2.3 Ficheiro .env

```env
DB_HOST=sql
DB_USER=car
DB_PASSWORD=car
DB_NAME=car_maintenance
```

---

## 3.3 Usage

A API fica disponível em:

```
http://localhost:8080
```

Documentação Swagger:

```
http://localhost:8080/api-docs
```

### Exemplos de utilização

#### Criar cliente

```json
{
  "nome": "João Martins",
  "email": "joao@gmail.com",
  "telefone": "912345678",
  "nif": "123456789",
  "morada": "Rua A"
}
```

#### Filtros de veículos

```
GET /veiculos?marca=BMW&estado=Disponivel&id_categoria=2
```

#### Criar reserva

```json
{
  "id_cliente": 1,
  "id_veiculo": 12,
  "id_funcionario": 8,
  "data_inicio": "2025-01-20 10:00:00",
  "data_fim": "2025-01-23 10:00:00",
  "preco_total": 120
}
```

## 3.4 Implementation details

Esta secção descreve o funcionamento interno da API Car4Me, com base no código real dos serviços (`ClientesService`, `FuncionariosService`, `VeiculosService`, `ReservasService`, `ManutencoesService` e `FavoritosService`).  
São apresentados os principais padrões usados, bem como excertos de código e regras de negócio aplicadas.

---

### 3.4.1 Clientes

O serviço de clientes implementa as operações:

- `clientesGET` – lista de clientes com informação adicional
- `clientesPOST` – criação de clientes
- `clientesIdGET` – detalhe de um cliente
- `clientesIdPUT` – atualização
- `clientesIdDELETE` – remoção com regras de negócio

Na listagem (`clientesGET`), para cada cliente são calculados campos derivados, por exemplo:

- se o cliente tem reservas associadas (`tem_reservas`);
- estado da última reserva;
- data da última reserva.

Isto é feito com sub-queries SQL agregadas sobre a tabela `reservas`.

Na remoção (`clientesIdDELETE`) é aplicada uma regra de negócio importante:

- se o cliente tiver **reservas ativas ou canceladas**, a eliminação é bloqueada;
- se tiver apenas reservas concluídas, é permitido apagar o cliente (e as reservas são removidas em cascata ou tratadas conforme a política definida).

Excerto simplificado do padrão usado na verificação:

```js
const clientesIdDELETE = ({ id }) =>
  new Promise(async (resolve, reject) => {
    try {
      sql.query(
        "SELECT estado FROM reservas WHERE id_cliente = ?",
        [id],
        (err, reservas) => {
          if (err) return reject(Service.rejectResponse(err.sqlMessage, 500));

          const temNaoConcluidas = reservas.some(
            (r) => r.estado !== "concluida"
          );

          if (temNaoConcluidas) {
            return reject(
              Service.rejectResponse(
                "Não é possível eliminar o cliente: possui reservas ativas ou canceladas.",
                400
              )
            );
          }

          // … eliminação segura do cliente …
        }
      );
    } catch (e) {
      reject(Service.rejectResponse(e.message, 500));
    }
  });
```
### 3.4.2 Funcionários

O serviço de funcionários possui operações equivalentes às restantes entidades:

- `funcionariosGET`
- `funcionariosPOST`
- `funcionariosIdGET`
- `funcionariosIdPUT`
- `funcionariosIdDELETE`

Assim como nos clientes, a listagem (`funcionariosGET`) calcula dinamicamente:

- se o funcionário tem reservas associadas;
- o estado da última reserva efetuada pelo funcionário;
- a data da última reserva.

Na eliminação (`funcionariosIdDELETE`) são aplicados dois passos:

1. **Confirmar se o funcionário existe.**  
2. **Verificar se possui reservas ativas.**

Se existirem reservas ativas:

- a API devolve **erro 400**
- a remoção é bloqueada

Além disso, existe uma lista de **funcionários protegidos**, que nunca podem ser removidos, por razões de histórico do sistema.

---

### 3.4.3 Veículos

O serviço de veículos implementa as operações:

- `veiculosGET` (com filtros)
- `veiculosPOST`
- `veiculosIdGET`
- `veiculosIdPUT`
- `veiculosIdDELETE`

A operação `veiculosGET` suporta os seguintes filtros:

- `estado` — `Disponivel`, `Alugado`, `Manutencao`
- `marca`
- `id_categoria`

O SQL é construído dinamicamente, adicionando cláusulas `WHERE` conforme os filtros fornecidos pelo utilizador.

Além dos campos básicos do veículo, são calculados:

- se o veículo tem reservas associadas;
- estado da última reserva;
- se existem manutenções associadas pendentes.

#### Regras de eliminação (veiculosIdDELETE)

Conforme descrito no Capítulo 2:

- **Veículos com reservas em estado `ativa` ou `cancelada` não podem ser apagados.**

Em caso de tentativa de remoção bloqueada:

- é criado um registo de log em `logs_veiculos_delete`.

#### Excerto resumido:

```js
const estadosBloqueados = ["ativa", "cancelada"];

const temReservaBloqueada = reservas.some((r) =>
  estadosBloqueados.includes(r.estado)
);

if (temReservaBloqueada) {
  sql.query(
    "INSERT INTO logs_veiculos_delete (id_veiculo, motivo) VALUES (?, ?)",
    [id, "Tentativa de apagar veículo com reservas em estado bloqueante"],
    () => {}
  );
  return reject(
    Service.rejectResponse(
      "Não é possível eliminar o veículo: possui reservas ativas ou canceladas.",
      400
    )
  );
}

```
### 3.4.4 Reservas

O serviço de reservas (`ReservasService`) disponibiliza as operações:

- `reservasGET` – listagem com filtros
- `reservasPOST` – criação
- `reservasIdGET` – detalhe por ID
- `reservasIdPUT` – atualização
- `reservasIdDELETE` – eliminação

#### Filtros disponíveis (`reservasGET`)

- `estado`
- `id_cliente`
- `id_veiculo`

#### Query base utilizada

```js
let query = "SELECT * FROM reservas WHERE 1=1";
const values = [];

if (estado) {
  query += " AND estado = ?";
  values.push(estado.trim());
}

if (id_cliente) {
  query += " AND id_cliente = ?";
  values.push(id_cliente);
}

if (id_veiculo) {
  query += " AND id_veiculo = ?";
  values.push(id_veiculo);
}
```
### 3.4.4 Reservas

O serviço de reservas (`ReservasService`) disponibiliza as operações:

- `reservasGET` – listagem com filtros  
- `reservasPOST` – criação  
- `reservasIdGET` – detalhe por ID  
- `reservasIdPUT` – atualização  
- `reservasIdDELETE` – eliminação  

#### **Validações realizadas (`reservasPOST`)**

Ao criar uma reserva, a API verifica:

- existência do cliente na base de dados;  
- existência do veículo;  
- existência do funcionário responsável;  
- validade das datas (**`data_inicio < data_fim`**).

#### **Eliminação (`reservasIdDELETE`)**

- devolve **404** caso a reserva não exista;  
- caso exista, elimina sem restrições adicionais, uma vez que reservas não dependem de outras entidades.

---

### 3.4.5 Manutenções

O serviço de manutenções (`ManutencoesService`) implementa:

- `manutencoesGET` – com filtro opcional por `id_veiculo`  
- `manutencoesPOST` – criação  
- `manutencoesIdGET` – detalhe  
- `manutencoesIdPUT` – atualização  
- `manutencoesIdDELETE` – eliminação  

#### **Query com filtro opcional**

```js
let query = "SELECT * FROM manutencoes WHERE 1=1";
const values = [];

if (id_veiculo) {
  query += " AND id_veiculo = ?";
  values.push(id_veiculo);
}
```

#### **Regras ao eliminar**

- devolve **404** se o `id_manutencao` não existir;  
- caso exista, elimina corretamente.

#### **Interação com triggers SQL**

Os triggers garantem coerência automática entre manutenção e estado dos veículos:

- veículos com manutenções pendentes permanecem em **Manutencao**;  
- ao criar ou atualizar uma manutenção, o estado do veículo é atualizado;  
- ao remover ou concluir uma manutenção, a BD ajusta o estado se aplicável;  
- evita inconsistências quando o acesso é direto à BD.

---

### 3.4.6 Favoritos (Relação N:N)

O `FavoritosService` gere a tabela `clientes_favoritos`, que representa a relação **N:N** entre clientes e veículos.

#### **Operações principais**

- `favoritosGET` – lista favoritos agrupados por cliente  
- `clientesIdClienteFavoritosIdVeiculoDELETE` – remove favorito  
- `clientesIdClienteFavoritosIdVeiculoPUT` – altera veículo favorito  
- `clientesIdClienteFavoritosIdVeiculoClientePUT` – altera cliente associado  

#### **Exemplo de resposta agregada**

```json
[
  {
    "id_cliente": 1,
    "veiculos": [3, 5, 7]
  },
  {
    "id_cliente": 2,
    "veiculos": [10, 12]
  }
]
```

#### **Validações**

A API verifica:

- existência do cliente;  
- existência do veículo;  
- envio dos parâmetros obrigatórios:
  - `novo_id_veiculo`
  - `novo_id_cliente`

---

### 3.4.7 Padrão de tratamento de erros e respostas

Todos os serviços utilizam o módulo comum `Service` para formatação das respostas.

#### **Métodos principais**

```js
Service.successResponse(data, statusCode);
Service.rejectResponse(message, statusCode);
```

#### **Benefícios**

- respostas JSON consistentes;  
- manuseamento padronizado de erros;  
- códigos HTTP corretos (200, 201, 400, 404, 500…);  
- redução de duplicação de lógica;  
- maior simplicidade e manutenção geral.

---

### 3.4.8 Triggers SQL e interação com a API

Além da lógica implementada em JavaScript, o sistema possui **triggers SQL** que reforçam regras de negócio automáticas.

#### **Regras automáticas**:

1. **Veículo criado em estado `Manutencao`**  
   → é gerada automaticamente uma manutenção.

2. **Manutenção criada ou atualizada**  
   → o veículo passa automaticamente para estado `Manutencao`.

3. **Veículo muda de `Manutencao` para `Disponivel` ou `Alugado`**  
   → todas as manutenções pendentes são removidas.


#### 3.4.8.1 Trigger `veiculo_criado_gera_manutencao`
**Objetivo:**  
Sempre que é criado um novo veículo diretamente no estado `Manutencao`, o sistema gera automaticamente um registo na tabela `manutencoes`, garantindo que o histórico reflete essa situação.

**Código completo:**

```sql
DELIMITER $$

CREATE TRIGGER veiculo_criado_gera_manutencao
AFTER INSERT ON veiculos
FOR EACH ROW
BEGIN
    IF NEW.estado = 'Manutencao' THEN
        INSERT INTO manutencoes (
            id_veiculo, descricao, data_manutencao, custo
        ) VALUES (
            NEW.id_veiculo,
            'Manutenção automática gerada ao criar veículo',
            NOW(),
            0
        );
    END IF;
END $$

DELIMITER ;
```
#### **Resumo da regra**
Se NEW.estado = 'Manutencao'
→ é criada automaticamente uma manutenção com custo 0 e descrição padrão.


## **3.4.8.2 Trigger `veiculo_sai_de_manutencao_apaga_manutencoes`**

#### **Objetivo**
Quando um veículo deixa o estado **Manutencao** (ex.: volta a `Disponivel` ou passa para `Alugado`), todas as manutenções pendentes associadas a esse veículo são eliminadas.

#### **Código completo**

```sql
DELIMITER $$

CREATE TRIGGER veiculo_sai_de_manutencao_apaga_manutencoes
AFTER UPDATE ON veiculos
FOR EACH ROW
BEGIN
    -- Veículo estava em Manutencao e saiu desse estado
    IF OLD.estado = 'Manutencao'
       AND NEW.estado IN ('Disponivel', 'Alugado') THEN

        DELETE FROM manutencoes
        WHERE id_veiculo = NEW.id_veiculo;

    END IF;
END $$

DELIMITER ;
```

#### **Resumo da regra**
Se `OLD.estado = 'Manutencao'`  
e `NEW.estado IN ('Disponivel','Alugado')`  
→ apaga todas as manutenções desse veículo.

---

### **3.4.8.3 Trigger `manutencao_criada_muda_estado`**

#### **Objetivo**
Sempre que é criada uma nova manutenção para um veículo, o estado desse veículo é automaticamente colocado em **Manutencao**.

#### **Código completo**

```sql
DELIMITER $$

CREATE TRIGGER manutencao_criada_muda_estado
AFTER INSERT ON manutencoes
FOR EACH ROW
BEGIN
    UPDATE veiculos
    SET estado = 'Manutencao'
    WHERE id_veiculo = NEW.id_veiculo;
END $$

DELIMITER ;
```

#### **Resumo da regra**

Ao inserir em `manutencoes`  
→ o veículo associado passa para estado `Manutencao`.

---

### **3.4.8.4 Trigger `manutencao_atualizada_muda_estado`**

#### **Objetivo**
Sempre que uma manutenção é atualizada, o sistema reforça que o veículo permanece em estado **Manutencao**, garantindo coerência.

#### **Código completo**

```sql
DELIMITER $$

CREATE TRIGGER manutencao_atualizada_muda_estado
AFTER UPDATE ON manutencoes
FOR EACH ROW
BEGIN
    UPDATE veiculos
    SET estado = 'Manutencao'
    WHERE id_veiculo = NEW.id_veiculo;
END $$

DELIMITER ;
```

#### **Resumo da regra**

Ao atualizar um registo de `manutencoes`  
→ o veículo continua (ou volta a) estado `Manutencao`.

---

### **3.4.8.5 Integração com a API e efeitos globais**

A atuação combinada dos quatro triggers com a lógica da API garante:

#### **Sincronização automática entre:**
- tabela `veiculos` (campo `estado`)
- tabela `manutencoes`

#### **Garantias do sistema**
- veículos com intervenções pendentes aparecem sempre em `Manutencao`;
- evita manutenções “órfãs” quando um veículo muda de estado;
- operações diretas SQL mantêm-se coerentes sem depender da API;
- consistência total mesmo em cenários de concorrência.

Deste modo, a base de dados aplica automaticamente as regras de negócio essenciais, assegurando **integridade lógica**, mesmo que a API não seja utilizada nas operações CRUD.




#### **Garantia de consistência**

A integração entre:

- validações da API  
- triggers SQL  
- constraints referenciais  

permite que o sistema:

- mantenha integridade mesmo com operações concorrentes;  
- permaneça consistente mesmo com alterações diretas à BD;  
- impeça estados inválidos via API;  
- garanta fiabilidade e robustez global.

### 3.4.8 Triggers SQL e interação com a API

Para além da lógica implementada na API (Node.js/Express), o sistema Car4Me recorre a **triggers SQL** na base de dados MySQL para garantir que o estado dos veículos e os registos de manutenção se mantêm coerentes.

Os triggers atuam automaticamente em resposta a operações de `INSERT` e `UPDATE` nas tabelas `veiculos` e `manutencoes`, aplicando regras de negócio críticas sem depender do código da aplicação.

---






#### Consistência

A combinação de:
- validações JS
- triggers SQL
- constraints

garante integridade mesmo com concorrência e alterações diretas à BD.

---

---
[< Previous](c2.md) | [^ Main](../../../) | [Next >](c4.md)
:--- | :---: | ---: 
