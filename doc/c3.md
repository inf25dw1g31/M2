# C3 : Product

Este capítulo descreve o desenvolvimento do produto, a sua instalação, utilização e detalhes técnicos de implementação.

---

## 3.1 Development

O desenvolvimento da API Car4Me foi realizado seguindo uma arquitetura **RESTful**, utilizando **Node.js + Express** no backend e **MySQL** como base de dados relacional. O sistema foi implementado de forma modular, garantindo clareza, reusabilidade e fácil manutenção.

A API foi separada nos seguintes módulos principais:

- Clientes  
- Veículos  
- Categorias  
- Reservas  
- Funcionários  
- Manutenções  
- Favoritos (relação N:N)  

Cada módulo possui:

- **Rota**  
- **Controller**  
- **Validações**  
- **Queries SQL**  

Assim assegura-se isolamento e coerência no produto.

> **[INSERIR AQUI]**  
> ![Arquitetura do Sistema](./imagens/c3/arquitetura_api.png)

### 3.1.1 Arquitetura da API

- Requests HTTP são recebidos nas rotas  
- Os controladores tratam da lógica  
- A base de dados armazena toda a informação  
- Respostas são devolvidas em JSON  

---

## 3.2 Installation

A API foi construída para ser executada de forma simples e portátil com **Docker**.

### 3.2.1 Passos de instalação

1. Instalar **Docker** e **Docker Compose**
2. Clonar o repositório:

```bash
git clone <url-do-projeto>
cd car4me
```

## 3.4 Implementation details

Esta secção descreve o funcionamento interno da API Car4Me, com base no código real dos serviços (`ClientesService`, `FuncionariosService`, `VeiculosService`, `ReservasService`, `ManutencoesService` e `FavoritosService`).  
São apresentados os principais padrões usados, bem como excertos de código e regras de negócio aplicadas.

---

### 3.4.1 Clientes

O serviço de clientes implementa as operações:

- `clientesGET` – lista de clientes com informação adicional
- `clientesPOST` – criação de clientes
- `clientesIdGET` – detalhe de um cliente
- `clientesIdPUT` – atualização
- `clientesIdDELETE` – remoção com regras de negócio

Na listagem (`clientesGET`), para cada cliente são calculados campos derivados, por exemplo:

- se o cliente tem reservas associadas (`tem_reservas`);
- estado da última reserva;
- data da última reserva.

Isto é feito com sub-queries SQL agregadas sobre a tabela `reservas`.

Na remoção (`clientesIdDELETE`) é aplicada uma regra de negócio importante:

- se o cliente tiver **reservas ativas ou canceladas**, a eliminação é bloqueada;
- se tiver apenas reservas concluídas, é permitido apagar o cliente (e as reservas são removidas em cascata ou tratadas conforme a política definida).

Excerto simplificado do padrão usado na verificação:

```js
const clientesIdDELETE = ({ id }) =>
  new Promise(async (resolve, reject) => {
    try {
      sql.query(
        "SELECT estado FROM reservas WHERE id_cliente = ?",
        [id],
        (err, reservas) => {
          if (err) return reject(Service.rejectResponse(err.sqlMessage, 500));

          const temNaoConcluidas = reservas.some(
            (r) => r.estado !== "concluida"
          );

          if (temNaoConcluidas) {
            return reject(
              Service.rejectResponse(
                "Não é possível eliminar o cliente: possui reservas ativas ou canceladas.",
                400
              )
            );
          }

          // … eliminação segura do cliente …
        }
      );
    } catch (e) {
      reject(Service.rejectResponse(e.message, 500));
    }
  });
```
### 3.4.2 Funcionários

O serviço de funcionários possui operações equivalentes às restantes entidades:

- `funcionariosGET`
- `funcionariosPOST`
- `funcionariosIdGET`
- `funcionariosIdPUT`
- `funcionariosIdDELETE`

Assim como nos clientes, a listagem (`funcionariosGET`) calcula dinamicamente:

- se o funcionário tem reservas associadas;
- o estado da última reserva efetuada pelo funcionário;
- a data da última reserva.

Na eliminação (`funcionariosIdDELETE`) são aplicados dois passos:

1. **Confirmar se o funcionário existe.**  
2. **Verificar se possui reservas ativas.**

Se existirem reservas ativas:

- a API devolve **erro 400**
- a remoção é bloqueada

Além disso, existe uma lista de **funcionários protegidos**, que nunca podem ser removidos, por razões de histórico do sistema.

---

### 3.4.3 Veículos

O serviço de veículos implementa as operações:

- `veiculosGET` (com filtros)
- `veiculosPOST`
- `veiculosIdGET`
- `veiculosIdPUT`
- `veiculosIdDELETE`

A operação `veiculosGET` suporta os seguintes filtros:

- `estado` — `Disponivel`, `Alugado`, `Manutencao`
- `marca`
- `id_categoria`

O SQL é construído dinamicamente, adicionando cláusulas `WHERE` conforme os filtros fornecidos pelo utilizador.

Além dos campos básicos do veículo, são calculados:

- se o veículo tem reservas associadas;
- estado da última reserva;
- se existem manutenções associadas pendentes.

#### Regras de eliminação (veiculosIdDELETE)

Conforme descrito no Capítulo 2:

- **Veículos com reservas em estado `ativa` ou `cancelada` não podem ser apagados.**

Em caso de tentativa de remoção bloqueada:

- é criado um registo de log em `logs_veiculos_delete`.

#### Excerto resumido:

```js
const estadosBloqueados = ["ativa", "cancelada"];

const temReservaBloqueada = reservas.some((r) =>
  estadosBloqueados.includes(r.estado)
);

if (temReservaBloqueada) {
  sql.query(
    "INSERT INTO logs_veiculos_delete (id_veiculo, motivo) VALUES (?, ?)",
    [id, "Tentativa de apagar veículo com reservas em estado bloqueante"],
    () => {}
  );
  return reject(
    Service.rejectResponse(
      "Não é possível eliminar o veículo: possui reservas ativas ou canceladas.",
      400
    )
  );
}

```
### 3.4.4 Reservas

O serviço de reservas (`ReservasService`) disponibiliza as operações:

- `reservasGET` – listagem com filtros
- `reservasPOST` – criação
- `reservasIdGET` – detalhe por ID
- `reservasIdPUT` – atualização
- `reservasIdDELETE` – eliminação

#### Filtros disponíveis (`reservasGET`)

- `estado`
- `id_cliente`
- `id_veiculo`

#### Query base utilizada

```js
let query = "SELECT * FROM reservas WHERE 1=1";
const values = [];

if (estado) {
  query += " AND estado = ?";
  values.push(estado.trim());
}

if (id_cliente) {
  query += " AND id_cliente = ?";
  values.push(id_cliente);
}

if (id_veiculo) {
  query += " AND id_veiculo = ?";
  values.push(id_veiculo);
}
```
### 3.4.4 Reservas

O serviço de reservas (`ReservasService`) disponibiliza as operações:

- `reservasGET` – listagem com filtros  
- `reservasPOST` – criação  
- `reservasIdGET` – detalhe por ID  
- `reservasIdPUT` – atualização  
- `reservasIdDELETE` – eliminação  

#### **Validações realizadas (`reservasPOST`)**

Ao criar uma reserva, a API verifica:

- existência do cliente na base de dados;  
- existência do veículo;  
- existência do funcionário responsável;  
- validade das datas (**`data_inicio < data_fim`**).

#### **Eliminação (`reservasIdDELETE`)**

- devolve **404** caso a reserva não exista;  
- caso exista, elimina sem restrições adicionais, uma vez que reservas não dependem de outras entidades.

---

### 3.4.5 Manutenções

O serviço de manutenções (`ManutencoesService`) implementa:

- `manutencoesGET` – com filtro opcional por `id_veiculo`  
- `manutencoesPOST` – criação  
- `manutencoesIdGET` – detalhe  
- `manutencoesIdPUT` – atualização  
- `manutencoesIdDELETE` – eliminação  

#### **Query com filtro opcional**

```js
let query = "SELECT * FROM manutencoes WHERE 1=1";
const values = [];

if (id_veiculo) {
  query += " AND id_veiculo = ?";
  values.push(id_veiculo);
}
```

#### **Regras ao eliminar**

- devolve **404** se o `id_manutencao` não existir;  
- caso exista, elimina corretamente.

#### **Interação com triggers SQL**

Os triggers garantem coerência automática entre manutenção e estado dos veículos:

- veículos com manutenções pendentes permanecem em **Manutencao**;  
- ao criar ou atualizar uma manutenção, o estado do veículo é atualizado;  
- ao remover ou concluir uma manutenção, a BD ajusta o estado se aplicável;  
- evita inconsistências quando o acesso é direto à BD.

---

### 3.4.6 Favoritos (Relação N:N)

O `FavoritosService` gere a tabela `clientes_favoritos`, que representa a relação **N:N** entre clientes e veículos.

#### **Operações principais**

- `favoritosGET` – lista favoritos agrupados por cliente  
- `clientesIdClienteFavoritosIdVeiculoDELETE` – remove favorito  
- `clientesIdClienteFavoritosIdVeiculoPUT` – altera veículo favorito  
- `clientesIdClienteFavoritosIdVeiculoClientePUT` – altera cliente associado  

#### **Exemplo de resposta agregada**

```json
[
  {
    "id_cliente": 1,
    "veiculos": [3, 5, 7]
  },
  {
    "id_cliente": 2,
    "veiculos": [10, 12]
  }
]
```

#### **Validações**

A API verifica:

- existência do cliente;  
- existência do veículo;  
- envio dos parâmetros obrigatórios:
  - `novo_id_veiculo`
  - `novo_id_cliente`

---

### 3.4.7 Padrão de tratamento de erros e respostas

Todos os serviços utilizam o módulo comum `Service` para formatação das respostas.

#### **Métodos principais**

```js
Service.successResponse(data, statusCode);
Service.rejectResponse(message, statusCode);
```

#### **Benefícios**

- respostas JSON consistentes;  
- manuseamento padronizado de erros;  
- códigos HTTP corretos (200, 201, 400, 404, 500…);  
- redução de duplicação de lógica;  
- maior simplicidade e manutenção geral.

---

### 3.4.8 Triggers SQL e interação com a API

Além da lógica implementada em JavaScript, o sistema possui **triggers SQL** que reforçam regras de negócio automáticas.

#### **Regras automáticas**:

1. **Veículo criado em estado `Manutencao`**  
   → é gerada automaticamente uma manutenção.

2. **Manutenção criada ou atualizada**  
   → o veículo passa automaticamente para estado `Manutencao`.

3. **Veículo muda de `Manutencao` para `Disponivel` ou `Alugado`**  
   → todas as manutenções pendentes são removidas.

#### **Garantia de consistência**

A integração entre:

- validações da API  
- triggers SQL  
- constraints referenciais  

permite que o sistema:

- mantenha integridade mesmo com operações concorrentes;  
- permaneça consistente mesmo com alterações diretas à BD;  
- impeça estados inválidos via API;  
- garanta fiabilidade e robustez global.

---
[< Previous](c2.md) | [^ Main](../../../) | [Next >](c4.md)
:--- | :---: | ---: 
